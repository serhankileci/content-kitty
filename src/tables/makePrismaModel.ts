import { Table } from "../util/index.js";

const makePrismaModel = (URI: string, tables: Table[]) => {
	const dataSource = `// Generated by Content Kitty, do NOT modify,\n// configure your Content Kitty tables object instead.\n\ndatasource db {\n\tprovider = "${
		URI.split(":")[0]
	}"\n\turl = env("DATABASE_URL")\n}\n\ngenerator client {\n\tprovider = "prisma-client-js"\n}\n\n`;

	// Toggle map for one-to-one relations
	const toggleMap: Record<string, boolean> = {};

	return (
		dataSource +
		tables
			.map(table => {
				const { fields, id } = table;
				const idType = !id?.type || id?.type === "autoincrement" ? "Int" : "String";
				const idDefault = id?.type ? `${id.type}()` : "autoincrement()";
				const idName = id?.name || "id";

				const model = [
					`model ${table.name} {`,
					`\t${idName} ${idType} @id @default(${idDefault})`,
				];

				for (const field of fields) {
					const { type } = field;
					const formattedField = field.name.replace(/\s/g, "_");
					const parts = ["\t" + formattedField];

					if (type === "relation") {
						const { many } = field;
						const ref = field?.ref as string;
						const baseRef = ref.split(".")[0];

						const relatedTable = tables.find(t => t.name === baseRef);

						if (relatedTable) {
							const relatedField = (relatedTable.fields as any).filter(
								(f: any) => f.type === "relation" && (f as any).ref
							)[0];

							let relationKind: "manyToMany" | "oneToMany" | "oneToOne" | undefined;

							if (relatedField) {
								const relatedMany = (relatedField as any).many;

								if (many && relatedMany) {
									relationKind = "manyToMany";
								} else if (many && !relatedMany) {
									relationKind = "oneToMany";
								} else if (!many && relatedMany) {
									relationKind = "oneToMany";
								} else if (!many && !relatedMany) {
									relationKind = "oneToOne";
								}

								parts.push(`${baseRef}${many ? "[]" : "?"}`);

								if (!many) {
									if (!toggleMap[baseRef!]) {
										toggleMap[baseRef!] = true;
									}

									const isToggled = toggleMap[table.name];

									if (
										(relationKind === "oneToMany" ||
											relationKind === "oneToOne") &&
										!isToggled
									) {
										parts.push(
											`@relation(fields: [${formattedField}Id], references: [id])`
										);
									}

									const undefinedOrAutoIncrementID =
										!relatedTable.id?.type ||
										relatedTable.id?.type === "autoincrement";

									parts.push(
										`\n\t${formattedField}Id ${
											undefinedOrAutoIncrementID ? "Int" : "String"
										}? @map("${formattedField}")`
									);

									if (relationKind === "oneToOne") {
										parts.push("@unique");
									}
								}
							}
						}
					} else {
						const { required, unique, map, defaultValue } = field as any;
						const capitalizedType = `${type[0]!.toUpperCase()}${type.slice(1)}`;
						parts.push(`${required ? capitalizedType : `${capitalizedType}?`}`);

						if (unique) parts.push("@unique");
						if (map) parts.push(`@map("${map}")`);
						if (defaultValue) {
							let value;

							if (type === "date" && typeof defaultValue === "object") {
								if (defaultValue.kind === "now") {
									value = defaultValue.kind + "()";
								} else if (defaultValue.kind === "updatedAt") {
									value = "@" + defaultValue.kind;
								}
							} else {
								value = JSON.stringify(defaultValue);
							}

							if (value?.startsWith("@")) parts.push(value);
							else parts.push(`@default(${value})`);
						}
					}

					model.push(parts.join(" "));
				}

				for (const field of fields) {
					const val = field as any;

					if (val.type !== "relation" && val.index) {
						model.push(`\t@@index([${val.name.replace(/\s/g, "_")}])`);
					}
				}

				model.push("}");
				return model.join("\n") + "\n";
			})
			.join("\n")
	);
};

export { makePrismaModel };
